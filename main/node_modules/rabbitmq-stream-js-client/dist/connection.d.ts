import { Compression, CompressionType } from "./compression";
import { Logger } from "./logger";
import { Request } from "./requests/request";
import { ConsumerUpdateQueryListener, DeliverListener, DeliverV2Listener, MetadataUpdateListener, PublishConfirmListener, PublishErrorListener } from "./response_decoder";
import { Response } from "./responses/response";
import { Version } from "./versions";
import { ClientListenersParams, ClientParams, ClosingParams, QueryOffsetParams, StoreOffsetParams } from "./client";
export type ConnectionClosedListener = (hadError: boolean) => void;
export type ConnectionListenersParams = ClientListenersParams & {
    deliverV1?: DeliverListener;
    deliverV2?: DeliverV2Listener;
    consumer_update_query?: ConsumerUpdateQueryListener;
};
export type ConnectionParams = ClientParams & {
    listeners?: ConnectionListenersParams;
    connectionId: string;
};
export type ConnectionInfo = {
    host: string;
    port: number;
    id: string;
    ready: boolean;
    readable?: boolean;
    writable?: boolean;
    localPort?: number;
};
export declare class Connection {
    private readonly params;
    private readonly logger;
    readonly hostname: string;
    readonly leader: boolean;
    readonly streamName: string | undefined;
    private socket;
    private correlationId;
    private decoder;
    private receivedResponses;
    private waitingResponses;
    private heartbeat;
    private compressions;
    private peerProperties;
    private readonly bufferSizeSettings;
    private frameMax;
    readonly connectionId: string;
    private connectionClosedListener;
    private serverEndpoint;
    private readonly serverDeclaredVersions;
    private refs;
    private filteringEnabled;
    userManuallyClose: boolean;
    private setupCompleted;
    publisherId: number;
    consumerId: number;
    private consumerListeners;
    private publisherListeners;
    private closeEventsEmitter;
    constructor(params: ConnectionParams, logger: Logger);
    private createSocket;
    private registerSocketListeners;
    private unregisterSocketListeners;
    restart(): Promise<void>;
    static connect(params: ConnectionParams, logger: Logger): Promise<Connection>;
    static create(params: ConnectionParams, logger: Logger): Connection;
    start(): Promise<Connection>;
    on(event: "metadata_update", listener: MetadataUpdateListener): void;
    on(event: "publish_confirm", listener: PublishConfirmListener): void;
    on(event: "publish_error", listener: PublishErrorListener): void;
    on(event: "deliverV1", listener: DeliverListener): void;
    on(event: "deliverV2", listener: DeliverV2Listener): void;
    on(event: "consumer_update_query", listener: ConsumerUpdateQueryListener): void;
    private logSocket;
    onPublisherClosed(publisherExtendedId: string, streamName: string, callback: () => void | Promise<void>): void;
    onConsumerClosed(consumerExtendedId: string, streamName: string, callback: () => void | Promise<void>): void;
    private registerListeners;
    getCompression(compressionType: CompressionType): Compression;
    registerCompression(compression: Compression): void;
    private exchangeCommandVersions;
    sendAndWait<T extends Response>(cmd: Request): Promise<T>;
    private waitResponse;
    getConnectionInfo(): ConnectionInfo;
    private responseReceived;
    private received;
    private exchangeProperties;
    send(cmd: Request): Promise<void>;
    private incCorrelationId;
    private getBufferSizeParams;
    get maxFrameSize(): number;
    get serverVersions(): Version[];
    get rabbitManagementVersion(): string;
    get isFilteringEnabled(): boolean;
    get ready(): boolean;
    private auth;
    private open;
    private tune;
    private calculateFrameMaxSizeFrom;
    close(params?: ClosingParams): Promise<void>;
    queryPublisherSequence(params: {
        stream: string;
        publisherRef: string;
    }): Promise<bigint>;
    storeOffset(params: StoreOffsetParams): Promise<void>;
    queryOffset(params: QueryOffsetParams): Promise<bigint>;
    incrRefCount(): void;
    decrRefCount(): number;
    get refCount(): number;
    getNextPublisherId(): number;
    getNextConsumerId(): number;
}
export declare function errorMessageOf(code: number): string;
export declare function connect(logger: Logger, params: ConnectionParams): Promise<Connection>;
export declare function create(logger: Logger, params: ConnectionParams): Connection;
export declare function partition<T>(arr: T[], predicate: (t: T) => boolean): [T[], T[]];
